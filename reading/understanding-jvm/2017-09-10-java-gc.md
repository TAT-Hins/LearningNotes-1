---
layout:     post
title:      "Java 垃圾收集器和内存分配策略"
categories: 深入理解Java虚拟机
author: luyao
---

* content
{:toc}

Java 和 C++ 之间有一堵由内存分配和垃圾收集技术所围成的 “高墙”，墙外的人想进去，墙里面的人想出来。




# 垃圾收集器与内存分配策略

Java 内存运行运行时区域的各个部分中，程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出执行着出栈和入栈操作，每一个栈帧中分配多少内存基本上在类结构确定下来时就是已知的。在这几个区域不需要过多考虑回收的问题。

而在 Java 堆和方法区则不一样。只有在程序处于运行期间才能知道会创建哪些对象，这部分内存的分配和回收是动态的，GC 所关注的是这部分内存。

## 如何判断对象是否需要回收

### 引用计数算法

给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1；当引用失效时，计数器值就减 1；任何时刻计数器为 0 的对象就是不可能再被使用的。

引用计数算法（Reference Counting）的实现简单，判定效率也很高。但是主流的 Java 虚拟机中没有选用引用计数算法来管理内存，最主要的原因是它很难解决对象之间相互循环引用的问题。

### 可达性分析算法

主流的商用程序语言的主流实现中，都是通过可达性分析（Reachability Analysis）来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为 “GC ROOTS” 的对象作为起点，从这些节点开始向下搜索，搜索走过的路径称为引用链（Reference Chain）。当一个对象到 GC ROOTS 没有任何引用链相连（就是从 GC ROOTS 到这个对象不可达）时，则证明这个对象是不可用的。

![](http://ofdkfbou7.bkt.clouddn.com/blog/gc-rechability-analysis.png)

在 Java 语言中，可作为 GC Roots 的对象包括下面几种：

* 虚拟机栈（栈帧中的本地变量表）中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中 JNI 引用的对象

### 引用

在 JDK 1.2 以前，Java 中的引用的定义很传统：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。

在 JDK 1.2 之后，Java 对引用的概念进行了扩充，分为强引用（Strong Reference），软引用（Soft Reference），弱引用（Weak Reference），虚引用（Phantom Reference）。

* 强引用就是指代码程序之间普遍存在的，类似 “Object obj = new Object()” 这类的引用。只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
* 软引用用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。
* 弱引用也是用来描述非必需对象的，但是强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前，当 GC 工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象。
* 虚引用是最弱的一种引用关系。一个对象是否又虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

### 生存还是死亡

即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂处于“缓刑”阶段。要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，都被视为没有必要执行。

任何一个对象的 finalize() 方法都只会被系统自动调用一次。

尽量避免使用。

### 回收方法区

在方法区（或者 HotSpot 虚拟机中的永生代）进行垃圾回收性价比一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾回收一般可以回收 70%-95% 的空间，而永久代的效率远低于此。

永久代的垃圾收集主要回收两部分：废弃常量和无用的类。类要满足下面三个条件才能算 “无用的类”：

* 该类的所有实例都已经被回收，也就是 Java 堆中不存在该类的任何实例
* 加载该类的 ClassLoader 已经被回收
* 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

## 垃圾收集算法

### 标记-清除算法

标记-清除（Mark-Sweep）算法分为 “标记” 和 “清除” 两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。对象标记判定如上可达性分析算法描述。

主要缺点:

* 效率问题，标记和清除两个过程的效率都不高
* 空间问题，标记清楚会产生大量不连续的内存碎片，空间碎片太多可能会导致需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

### 复制算法

复制（Copying）收集算法，将可用内存按容量分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

* 每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效
* 代价是将内存缩小为了原来的一半

现在的商业虚拟机都采用这种收集算法来回收新生代。

新生代中的对象 98% 都是“朝生夕死” 的。一般将内存分为一块较大的 Eden 空间和 两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另外一块 Suivivor
 空间上，最后清理掉 Eden 和 刚才用过的 Survivor 空间。

 HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8:1。我们没法保证每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。

### 标记-整理算法

老年代的对象存活率较高，不适用复制算法。使用标记-整理算法。

标记-整理算法过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

### 分代收集算法

当前商业虚拟机的垃圾收集都采用 “分代收集（Generational Collection）” 算法，根据对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代。

* 新生代中每次 GC 都发现有大量对象死去，只有少量存活，使用复制算法，只需付出极少存活对象的复制成本
* 老年代中因为对象存活率高，没有额外空间对它进行分配担保，就必须使用 “标记-清理” 或者 “标记-整理” 算法

## HotSpot 的算法实现

可达性分析对执行时间的敏感还体现在 GC 停顿上。在整个分析期间整个执行系统看起来就像被冻结在某个时间点，不可以出现分析过程中对象引用关系还在变化情况，这点导致 GC 进行时必须停顿所有的 Java 执行线程（Stop The World）。

程序执行时并非在所有地方都能停顿下来开始 GC，只有到达安全点（Safepoint）时才能暂停。

如何在 GC 发生时让所有线程（这里不包括执行 JNI 调用的线程）都运行到最近的安全点上再停顿下来，两种方案：

* 抢先式中断（Preemptive Suspension）：在 GC 发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑到安全点上。现在几乎没有虚拟机使用抢先式中断来暂停线程从而响应 GC
* 主动式中断（Voluntary Suspension）: 当 GC 需要中断线程的时候，仅仅简单的设置一个标志，各个线程执行时主动的去轮询这个标志，发现中断标志为真时就自己中断挂起，轮询标志的地方和安全点是重合的

安全区域（Safe Region）是指在一段代码片段中，引用关系不会发生改变，在这个区域中的任意地方开始 GC 都是安全的，可以把 Safe Region 看成扩展了的 Safe Point

## 垃圾收集器

![](http://ofdkfbou7.bkt.clouddn.com/blog/hotspot-collector.jpg)

上图是基于 JDK 1.7 Update 14 之后的 HotSpot 虚拟机。展示了 7 种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。

### Serial 收集器

JDK 1.3 之前虚拟机新生代的唯一选择，是一个单线程的收集器。在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束，给用户带来不良体验。

但它依然是虚拟机运行在 Client 模式下的默认新生代收集器，因为它的简单高效，对于限定在单个 CPU 的环境来说，没有线程交互的开销。

### ParNew 收集器

Serial 收集器的多线程版本，除了使用多条线程进行垃圾回收之外，其余行为包括 Serial 收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与 Serial 收集器完全一样。

除了 Serial 收集器以外，目前只有它能与 CMS 收集器配合工作，所以它是许多运行在 Server 模式下的虚拟机中首选的新生代收集器。

ParNew 收集器在单个 CPU 的环境中绝对不会有比 Serial 收集器更好的效果。

### Parallel Scavenge 收集器

Parallel Scavenge 收集器也是一个新生代收集器，使用复制算法，也是并行的多线程收集器。

与其他收集器不同的是，CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目的是达到一个可控制的吞吐量，所谓吞吐量就是 CPU 用于运行用户代码的时间和 CPU 总消耗时间的比值，即：

`  吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）`

高吞吐量可以高效率的利用 CPU 时间，尽快完成运算任务，适合在后台运算不需要太多交互的任务。

Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量：

* `-XX:MaxGCPauseMillis` : 控制最大垃圾收集停顿时间
* `-XX:GCTimeTatio`：直接设置吞吐量大小

GC 停顿时间缩短是以牺牲吞吐量和新生代空间来换取的。

* `-XX:+UseAdaptiveSizePolicy`：此参数打开后无需手工指定新生代的大小、 Eden 和 Survivor 区的比例、晋升老年代对象大小等细节参数，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这叫做 GC 自适应的调节策略。

### Serial Old 收集器

Serial Old 是 Serial 的老年代版本，单线程收集器，使用 `标记-整理`算法，主要是给 Clinet 模式下的虚拟机使用。如果在 Server 模式下，主要有两大用途：

* 在 JDK 1.5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用
* 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用

### Parallel Old 收集器

Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和`标记-整理`算法，在 JDK 1.6 中才开始提供。在此之前，如果新生代选择了 Parallel Scavenge 收集器，老年代除了 Serial Old 收集器别无选择，使得在整体应用上未必能获得吞吐量最大的效果。

在注重吞吐量和 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

### CMS 收集器

CMS(Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器，基于 `标记-清除` 算法，它的运作过程相对前面几种收集器更复杂，分为  4 个步骤：

* 初始标记（CMS initial mark）
* 并发标记（CMS  concurrent mark）
* 重新标记（CMS remark）
* 并发清除（CMS concurrent sweep）

初始标记、重新标记仍然需要 `Stop The World`。
初始标记仅仅只是标记一下 GC Roots 能直接关联的对象，速度很快。
并发标记阶段就是进行 GC Roots Tracing 的过程。
重新标记阶段是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。

由于整个过程中耗时最长的并发标记和并发清除过程收集器线程可以和用户线程一起工作，所以总的来说，CMS 的内存回收过程是与用户线程一起并发执行的。

CMS 的 3 个明显缺点：

* CMS 收集器对 CPU 资源非常敏感。在并发过程中，虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说 CPU 资源）而导致应用程序变慢，总吞吐量会降低。`CMS 默认启动的回收线程数是 (CPU数量+3)/4`。CPU 数量较少时，对用户程序的影响会变得很大。

* CMS 收集器无法处理浮动垃圾（Floating Carbage），可能出现 `Concurrent Mode Failure` 失败而导致另一次 Full GC 的产生。由于 CMS 并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS 无法在当次收集中处理掉他们，只好留待下一次 GC 时再清理掉。这一部分垃圾就称为 `浮动垃圾`。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留足够的内存空间给用户线程使用，因此 CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。

* CMS 是基于 `标记-清除` 算法实现的收集器，会有大量空间碎片产生，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次 Full GC。为此提供了两个参数：
`-XX:+UseCMSCompactAtFullCollection`：用于在 CMS 收集器顶不住要进行 Full GC 时开启内存碎片的合并整理过程。（内存整理是无法并发的，会使得停顿时间变长），此参数默认是开启的。`-XX:CMSFullGCsBeforeCompaction`: 用于设置执行多少次不压缩的 Full GC 后，跟着来一次带压缩的。默认值为0，表示每次进入 Full GC 都进行碎片整理。

### G1 收集器

G1（Garbage First）收集器是当今收集器技术发展的最前沿成果之一，是一款面向服务端应用的垃圾收集器。HotSpot 开发团队赋予它的使命是（在比较长期的）未来可以替换掉 JDK1.5 中发布的 CMS 收集器。G1 具备如下特点：

* 并行与并发。G1 能充分利用多 CPU、多鹤环境下的硬件优势，使用多个 CPU 来缩短 Stop The World 停顿的时间，部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 Java 程序继续执行。
* 分代收集。G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，并能采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次 GC 的旧对象以获取更好的收集效果。
* 空间整合。G1 从整体上看是基于 `标记-整理` 算法实现的收集器，从局部（两个 Region 之间）上来看是基于 `复制` 算法实现的。无论如何，这两种算法都意味着 G1 运作期间不会产生空间碎片，收集后能提供规整的可用内存。
* 可预测的停顿。G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集的时间不得超过 N 毫秒，这几乎已经是实时 Java（RTSJ）的垃圾收集器的特征了。

使用 G1 收集器时，Java 堆的内存布局与其他收集器有很大差别。它将整个 Java 堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region(不需要连续)的集合。

G1 之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。

## 内存分配与回收策略

### 对象优先在 Eden 分配

大多数情况下，对象在新生代 Eden 区中分配。当 Eedn 区没有足够的空间进行分配时，虚拟机将发起一次 Minor GC。

* Minor GC(新生代 GC)：指发生在新生代的垃圾收集动作，因为 Java 对象大多数都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。
* Major GC/Full GC(老年代 GC)：指发生在老年代的 GC，出现了 Major GC，经常会伴随至少一次的 Minor GC。Major GC 的速度一般会比 Minor GC 慢 10 倍以上。

### 大对象直接进入老年代

大对象，一般指需要大量连续内存空间的 Java 对象，最典型的就是长字符串和大数组。经常出现大对象容易导致内存还有不少空间时就提前触发垃圾回收以获取足够的连续空间来安置它们。

`-XX:PretenureSizeThreshold` 参数，令大于这个设置值的对象直接老年代分配。这样做的目的是避免在 Eden 区及两个 Survivor 区之间发生大量的内存复制（新生代采用复制算法收集内存）。

### 长期存活的对象将进入老年代

虚拟机给每个对象定义了一个对象年龄计数器。如果对象在 Eden 中出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为 1。对象每在 Survivor 区中熬过一次 Minor GC，年龄就增加 1 岁。当年龄增加到一定程度时（默认是 15 岁），就将会晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThresold` 设置。

### 动态对象年龄判定

虚拟机并不是永远的要求对象的年龄必须达到了 `MaxTenuringThresold` 才能晋升老年代。如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。

### 空间分配担保

在发生 Minor GC 前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立的话，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 `HandlePromotionFailure` 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者设置不允许冒险，这时要改为进行一次 Full GC。

`JDK 6 Update 24` 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行 Minor GC，否则进行 Full GC。
