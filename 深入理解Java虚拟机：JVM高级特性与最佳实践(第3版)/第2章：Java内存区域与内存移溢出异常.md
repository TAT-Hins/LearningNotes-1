
## 运行时数据区域

![](http://cdn.luyao.tech/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png)

### 程序计数器

程序计数器是一块较小的内存空间，它可以看做会当前线程所执行的字节码的行号指示器。在 Java 虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器 值来选取下一条需要执行的字节码指令。它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

每条线程都有独立的程序计数器，各条线程之间的程序计数器互不影响，独立存储，是线程私有的。

此内存区域是唯一一个在 《Java 虚拟机规范》 中没有规定任何 OutOfMemoryError 情况的区域。

### Java 虚拟机栈

Java 虚拟机栈也是线程私有的，它的生命周期和线程相同。

每个方法被执行的时候，Java 虚拟机栈都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法被调用直到执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常。
如果 Java 虚拟机栈支持动态扩展，当栈扩展时无法申请到足够的内存会排抛出 OutOfMemoryError 异常。

HotSpot 虚拟机的栈容量是不可以动态扩展的。

### 本地方法栈

为虚拟机使用到的 Native 方法服务。

《Java 虚拟机规范》对本地方法栈中方法使用的语言、使用方式和数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它。

Hotspot 将本地方法栈和虚拟机栈合二为一。

本地方法栈也会在栈深度溢出和栈扩展失败时分别抛出 StackOverflowError 和 OutOfMemoryError 。

### Java 堆

Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java 世界里 “几乎” 所有的对象实例都在这里分配内存。在 《Java 虚拟机规范》中对 Java 堆的描述是：“所有的对象实例以及数组都应当在堆上分配”。

Java 堆以处于物理上不连续的内存空间，但在逻辑上它应该被视为连续的。但对于大对象(典型的如数组对象)，多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。

Java 堆既可以被实现成固定大小，也可以是扩展的。如果在 Java 堆中没有内存完成实例分配，并且堆无法再扩展时，Java 虚拟机将会抛出 OutOfMemoryError 。

### 方法区

方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

虽然《Java 虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做“非堆”，目的是与 Java 堆分开来。

Hotspot 设计之初选择把垃圾收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，使得 HotSpot 的 GC 能够像管理 Java 堆一样管理这部分内存，但导致 Java 应用更容易遇到内存溢出的问题。在 JDK 8 中，彻底废弃了永久代的概念。

如果方法区无法满足新的内存分配的需求时，将抛出 OutOfMemoryError 。

### 运行时常量池

运行时常量池是方法区的一部分。Class 文件的常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后方法方法去的运行时常量池。

运行时常量池具有动态性，运行期间也可以将新的常量放入池中，如 `String.intern()` 。

常量池受到方法区的限制，当无法再申请到内存时，会抛出 OutOfMemoryError 。

### 直接内存

直接内存并不是虚拟机运行时数据区的一部分，也不是《Java 虚拟机规范》中定义的内存区域，但这部分也会被频繁使用，也可能造成 OutOfMemoryError 。

在 JDK 1.4 中新加入了 NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里面的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。

本机直接内存受到本机总内存大小以及处理器寻址空间的限制。

## 对象的创建

当 Java 虚拟机遇到一条字节码 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载，解析和初始化过。如果没有，那必须先执行相应的类加载过程。

在 Hotspot 虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：**对象头**、**实例数据**、**对齐填充** 。

**对象头** 部分包括两类信息：

* 第一部分用于存储对象自身的运行时数据，如哈希码，GC 分代年龄、锁标志状态、线程持有的锁、偏向线程 ID、偏向时间戳等。这部分数据的长度在 32 位和 64 位的虚拟机（未开启压缩指针）中分别为 32 个比特和 64 个比特，官方称它为 “Mark Word” 。
* 另一部分是类型指针，即对象指向它的类型元数据的指针。Java 虚拟机通过这个指针来确定该对象是哪个类的实例。如果对象是一个 Java 数组，对象头中还必须有一块用于记录数组长度的数据。

**实例数据** 部分是对象真正存储的有效信息，即我们在程序代码里面定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。

**对象填充** 部分并不是必然存在的，也没有特别的含义，仅仅起着占位符的作用。HotSpot 虚拟机的自动内存管理系统要求对象的起始地址必须是 8 字节的整数倍。
