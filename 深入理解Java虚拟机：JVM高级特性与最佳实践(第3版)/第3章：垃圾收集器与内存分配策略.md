事实上，垃圾收集的历史远比 Java 悠久。在 1960 年诞生于麻省理工学院的 Lisp 是第一门开始使用内存动态分配 垃圾收集技术的语言。

## 引用计数法

在对象中添加一个引用计数器，每有一个地方引用它时，计数器值就加 1；当引用失效时，计数器值就减 1 ；任何时刻计数器值为 0 的对象就是不可能再被使用的。

虽然占用一定的额外空间来进行计数，但原理简单，判定效率高。

主流的 Java 虚拟机都没有选用引用计数法来管理内存，因为它需要考虑很多特殊情况，必须配合大量额外处理才能保证正常工作。例如，循环引用问题。

## 可达性分析算法

通过一系列称为 **GC Roots**  的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程走过的路径称为 “引用链”，如果某个对象到 GC Roots 之间没有任何引用链相连，即从 GC Roots 到这个对象不可达时，即证明此对象不可能再被使用。

在 Java 体系中，固定可作为 GC Roots 的对象包括下面几种：

* 在虚拟机栈（栈帧中的本地方法表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
* 在方法区中类静态属性引用的对象，譬如 Java 类的引用类型静态变量。
* 在方法区中常量引用的对象，譬如字符串常量池中的引用。
* 在本地方法栈中 Jni 引用的对象。
* Java 虚拟机内部的引用，譬如基本数据类型对应的 class 对象，一些常驻的异常对象，系统类加载器等。
* 所有被同步锁持有的对象。
* 反映 Java 虚拟机内部情况的 JXMBean、JVMTI 中注册的回调、本地代码缓存等。

## 几种引用

**强引用**，程序代码之间普遍存在的引用赋值。无论任何情况下，只要强引用关系还在，垃圾收集器就不会回收掉被引用的对象。

**软引用**，被软引用关联的对象，在系统即将发生内存溢出之前，会把这些对象列进回收范围之中进行二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。用 `SoftReference` 实现。

**弱引用**，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。用 `WeakReference` 实现。

**虚引用**，也叫 **幽灵引用** 或 **幻影引用**。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。用 `PhantomReference` 实现。

即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。假如对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。

不要依赖 finalize() 方法来拯救对象。它运行代价高，不确定性大，无法保证各个对象的调用顺序。
