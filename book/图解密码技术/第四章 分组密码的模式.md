**分组密码（block cipher）:** 每次只能处理特定长度的一块数据的一类密码算法。DES 和 三重 DES 的分组长度都是 64 比特。AES 的分组长度为 128 比特。

**流密码（stream cipher）:** 对数据流进行连续处理的一类密码算法。流密码以 1 比特、8 比特或者 32 比特等为单位进行加密和解密。

## ECB 模式

Electronic CodeBook mode , 电子密码本模式。将明文分组加密之后的结果直接成为密文分组。所以相同的明文分组会被转换为相同的密文分组。也就是说，我们可以将其理解为是一个巨大的 “明文分组 -> 密文分组” 的对应表。

当最后一个明文分组的内容小于分组长度时，需要用一些特定的数据进行 **填充（padding）**。

ECB 模式是所有模式中最简单的一种，明文分组和密文分组是一一对应的关系。因此，如果明文中存在多个相同的明文分组，则这些明文分组最终都将被转换为相同的密文分组。因此，ECB 模式是存在一定风险的。

在 ECB 模式中，只要对任意密文分组进行替换，相应的明文分组也会被替换。删除，复制也同样。

![image](G:/blog/note/image/ECB.png)

## CBC 模式

Cipher Block Chainning ，密文分组链接模式。（密文分组像链条一样链接在一起）

在 CBC 模式中，首先将明文分组与前一个密文分组进行 XOR 运算，然后再进行加密。ECB 模式只进行了加密，而 CBC 模式在加密之前进行了一次 XOR。

![image](G:/blog/note/image/CBC.png)

当加密第一个明文分组时，由于不存在 `前一个密文分组` ，因此需要事先准备一个长度为一个分组的比特序列来代替 `前一个密文分组`，这个比特序列称为 `初始化向量`，通常缩写为 `IV`。一般来说，每次加密时都会随机产生一个不同的比特序列来作为初始化向量。

假设 CBC 模式加密的密文分组中有一个分组损坏了，在这种情况下，只要密文分组的长度没有发生变化，则解密时最多只有 2 个分组受到数据损坏的影响。

假设 CBC 模式的密文分组中有一些比特丢失了，即便只缺失一个字节，也会导致密文分组的长度发生变化，此后的分组发生错位，缺失比特的位置之后的密文分组也就全部无法解密了。

## CFB

CFB ，Cipher FeedBack，密文反馈模式。

在 CFB 模式中，前一个密文分组会被送回到密码算法的输入端。所谓反馈，这里指的就是返回输入端的意思。

![image](G:/blog/note/image/CFB.png)

在 CFB 模式中，明文分组并没有通过密码算法来直接进行加密。明文分组和密文分组之间只有一个 XOR。

CFB 模式通过将 `明文分组` 和 `密码算法的输出` 进行 XOR 运算来生成 `密文分组`的。密码算法的输出相当于一次性密码本的随机比特序列。

CFB 模式中由密码算法所生成的比特序列称为 `密钥流（key stream）`。在 CFB 模式中，密码算法就相当于用来生成密钥流的伪随机数生成器，而初始化向量就相当于伪随机数生成器的 `种子`。明文数据可以被逐比特加密。因此 CFB 模式可以看作是一种 **使用分组密码来实现流密码** 的方式。

## OFB 模式

OFB ，Output-FeedBack ，输出反馈模式。密码算法的输出会反馈到密码算法的输入中。

同 CFB 相似，将 `明文分组` 和 `密码算法的输出` 进行 XOR 来产生 `密文分组`。

![image](G:/blog/note/image/OFB.png)

OFB 模式与 CFB 模式的区别仅仅在于密码算法的输入。
CFB 模式中，密码算法的输入是前一个密文分组。
OFB 模式中，密码算法的输入是密码算法的前一个输出。

由于 CFB 模式中是对密文分组进行反馈的，因此必须从第一个明文分组开始按顺序进行加密，也就是说无法跳过明文分组1而先对明文分组2进行加密。

相对地，在 OFB 模式中，XOR 所需要的比特序列（密钥流）可以事先通过密码算法生成，和明文分组无关。只要提前准备好所需的密钥流，则在实际从明文生成密文的过程中，就完全不用动用密码算法了，只要将明文和密钥流进行 XOR 就好了。这就意味着只要提前准备好密钥流就可以快速完成加密。换个角度看，生成密钥流的操作和进行 XOR 运算的操作是可以并行的。

## CTR 

CTR ， CounTer，计数器模式。

CTR 模式是一种通过将逐次累加的计数器进行加密来生成密钥流的流密码。最终的密文分组是通过将计数器加密得到的比特序列，与明文分组进行 XOR 而得到的。

![image](G:/blog/note/image/CTR.png)

每次加密都会生成一个不同的值（nonce）来作为计数器的初始值。当分组长度为 128 比特时，其中前 8 个字节为 nonce，这个值在每次加密时必须都是不同的。后 8 个字节为分组序号，这个部分是会逐次累加的。由此可以保证计数器的值每次都不用，因此加密的密钥流也不同。

CTR 模式中可以以任意顺序对分组进行加密和解密。也就意味着能够实现并行计算。

