链表不需要连续的内存空间，它通过 “指针” 将一组零散的内存块串联起来使用。

![](https://static001.geekbang.org/resource/image/d5/cd/d5d5bee4be28326ba3c28373808a62cd.jpg)

## 单链表

![](https://static001.geekbang.org/resource/image/b9/eb/b93e7ade9bb927baad1348d9a806ddeb.jpg)

头结点用来记录链表的基地址。
尾节点的后继指针不是指向下一结点，而是指向 null 。

链表的插入和删除元素的时间复杂度是 O(1) 。
链表的随机访问，需要从头结点逐个遍历，时间复杂度为 O(n)。

## 循环链表

一种特殊的单链表，链表的尾节点指向链表的头结点。

![](https://static001.geekbang.org/resource/image/86/55/86cb7dc331ea958b0a108b911f38d155.jpg)

## 双向链表

单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。

![](https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg)

如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。

双向链表相比单向链表的优势在哪里？注意下面两种情况：

1. 删除结点中“值等于某个给定值”的结点
2. 删除给定指针指向的结点

第一种情况，不管是单还是双，都是 O(n) 。虽然链表的删除是 O(1)，但时间都花在了寻找 “值等于某个给定值” 的结点上。

第二种情况，单链表仍然是 O(n)，因为要遍历寻找到指定结点的前一个结点。而双链表可以通过前驱指针直接找到，是 O(1) 的操作。

**空间换时间** 。

## 数组和链表对比

数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。

链表天然支持动态扩容，而数组不支持。

链表比数组更占内存。

## 用链表实现 LRU ？

思路：

1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
2. 如果此数据没有在缓存链表中，又可以分为两种情况：如果此时缓存未满，则将此结点直接插入到链表的头部；如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。

代码见： [LRUBaseLinkedList.java](https://github.com/wangzheng0822/algo/blob/master/java/06_linkedlist/LRUBaseLinkedList.java)